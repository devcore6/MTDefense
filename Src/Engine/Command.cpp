// Credit: Command system is inspired by the system in Cube 2 @ https://sourceforge.net/p/sauerbraten/
#include "Engine.hpp"
#include <fstream>
#include <iomanip>

std::vector<std::pair<std::string, std::string>>    functions;
std::vector<std::pair<std::string, std::string>>    aliases;

std::vector<command_t>                              commands;
std::vector<var_t<intmax_t>>                        ivars;
std::vector<var_t<uint32_t>>                        hvars;
std::vector<var_t<double>>                          dvars;
std::vector<var_t<bool>>                            bvars;
std::vector<svar_t>                                 svars;

void savevars() {
    std::ofstream config;
    config.open("Data/Config/Config.conf");
    if(!config.is_open()) return;
    config << "// Autogenerated main configuration file" << std::endl;
    const auto& save = [&]<typename T>(std::vector<T>&V, std::string prefix = ""_str, std::string suffix = ""_str) { for(auto& var : V) if(var.persist) config << var.name << " " << prefix << *var.ptr << suffix << ";\n"; };
    save(ivars);
    config << std::hex;
    save(hvars, "0x");
    config << std::dec;
    save(dvars);
    save(bvars);
    save(svars, "\""_str, "\""_str);
    config.close();
}

bool to_bool(std::string& s) { return s == "1" || s == "true"; }

constexpr char identifier_valid_characters[] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                                                 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                                                 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                                                 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 0 };

// Replace escape sequences
/*
replace_all(cmd, "\\\'", "\'");
replace_all(cmd, "\\\"", "\"");
replace_all(cmd, "\\\?", "\?");
replace_all(cmd, "\\\\", "\\");
replace_all(cmd, "\\a" , "\a");
replace_all(cmd, "\\b" , "\b");
replace_all(cmd, "\\f" , "\f");
replace_all(cmd, "\\n" , "\n");
replace_all(cmd, "\\r" , "\r");
replace_all(cmd, "\\t" , "\t");
replace_all(cmd, "\\v" , "\v");
*/

void parsecmd(std::string cmd) {
    // Remove comments
    erase_all(cmd, "//", "\n");
    erase_all(cmd, "/*", "*/");

    // Remove line breaks
    erase_all(cmd, "\n");
    erase_all(cmd, "\r");

    // Handle aliases and functions
    if(!match_all(cmd, "=", [](std::string& cmd, size_t pos) -> bool {
        // Get identifier
        size_t start_pos = pos - 1;
        while(start_pos != 0 && cmd[start_pos] == ' ') start_pos--;
        if(start_pos == 0 || !contains(identifier_valid_characters, cmd[start_pos])) {
            conerr("Error: Expected unqualified id before '='");
            return false;
        }
        std::string identifier = "";
        while(start_pos != 0 && contains(identifier_valid_characters, cmd[start_pos])) {
            identifier = ""_str + cmd[start_pos] + identifier;
            start_pos--;
        }
        if(start_pos == 0 && contains(identifier_valid_characters, cmd[start_pos])) identifier = std::string("") + cmd[start_pos] + identifier;

#define check(arr, member) for(auto& x : arr) if(x.member == identifier) { conerr("Cannot redefine built-in \"" + identifier + "\""); return false; }

        check(commands, first);
        check(ivars, name);
        check(dvars, name);
        check(bvars, name);
        check(svars, name);

#undef check

        for(size_t i = 0; i < functions.size(); i++) if(functions[i].first == identifier) functions.erase(functions.begin() + i);
        for(size_t i = 0; i < aliases.size();   i++) if(aliases[i]  .first == identifier) aliases  .erase(aliases  .begin() + i);

        pos++;
        while(cmd[pos] == ' ') pos++;

        // Function declaration
        if(cmd[pos] == '{') {
            pos++;
            size_t decl_start = pos;
            size_t brace_count = 1;
            while(cmd[pos]) {
                if(cmd[pos] == '{') brace_count++;
                else if(cmd[pos] == '}') {
                    brace_count--;
                    if(brace_count == 0) break;
                }
                pos++;
            }
            if(brace_count != 0) conerr("Expected '}'");
            std::string f = cmd.substr(decl_start, pos - decl_start);
            functions.push_back(std::make_pair(identifier, f));
            cmd.erase(start_pos, pos - start_pos);
            return true;
        }
        
        // Alias declaration
        // String
        if(cmd[pos] == '"') {
            pos++;
            size_t end_pos = find_not_escaped(cmd, "\"", pos);
            std::string value = cmd.substr(pos, end_pos - pos);

            // Escape characters

            replace_all(value, "\\\'", "\'");
            replace_all(value, "\\\"", "\"");
            replace_all(value, "\\\?", "\?");
            replace_all(value, "\\\\", "\\");
            replace_all(value, "\\a", "\a");
            replace_all(value, "\\b", "\b");
            replace_all(value, "\\f", "\f");
            replace_all(value, "\\n", "\n");
            replace_all(value, "\\r", "\r");
            replace_all(value, "\\t", "\t");
            replace_all(value, "\\v", "\v");

            aliases.push_back(std::make_pair(identifier, value));
            if(cmd.find(";", end_pos) == std::string::npos) conerr("Expected ';'");
            cmd.erase(start_pos, cmd.find(";", end_pos) - start_pos);
            return true;
        }
        // Non-String
        size_t end_pos = cmd.find(";", pos);
        if(end_pos == std::string::npos) conerr("Expected ';'");
        size_t next_separator = cmd.find(" ", pos);
        std::string value = cmd.substr(pos, min(end_pos, next_separator) - pos
        );
        aliases.push_back(std::make_pair(identifier, value));
        cmd.erase(start_pos, end_pos - start_pos);
        return true;
    })) return;

    std::vector<std::string> cmds = split(cmd, ';', '\"', true);
    for(auto& c : cmds) { execcmd(c); }
}

void execcmd(std::string cmd) {
    std::vector<std::string> args = split(cmd, ' ', '\"');
    if(args.size() == 0) return;

    for(auto& arg : args) {
        replace_all(arg, "\\\'", "\'");
        replace_all(arg, "\\\"", "\"");
        replace_all(arg, "\\\?", "\?");
        replace_all(arg, "\\\\", "\\");
        replace_all(arg, "\\a", "\a");
        replace_all(arg, "\\b", "\b");
        replace_all(arg, "\\f", "\f");
        replace_all(arg, "\\n", "\n");
        replace_all(arg, "\\r", "\r");
        replace_all(arg, "\\t", "\t");
        replace_all(arg, "\\v", "\v");
    }

    command_t* cur = nullptr;
    for(auto& c : commands) if(c.first == args[0]) cur = &c;

    if(!cur) {
    
        if(args.size() == 1) {

#define check(arr, conversion) for(auto& x : arr) if(x.name == args[0]) { conout(conversion(*x.ptr)); return; }

            check(ivars, std::to_string);
            check(hvars, std::to_string);
            check(dvars, std::to_string);
            check(bvars, std::to_string);
            check(svars, );

#undef check

            conerr("Unknown command: "_str + args[0]);

        } else {

#define check(arr, conversion, suffix) for(auto& x : arr) if(x.name == args[0]) { *x.ptr = conversion(args[1] suffix); return; }

            check(ivars, atoll, .c_str());
            check(hvars, [](std::string s) -> uint32_t { if(s.substr(0, 2) == "0x") return std::strtoul(s.c_str(), nullptr, 16); return (uint32_t)std::strtoul(s.c_str(), nullptr, 10); }, );
            check(dvars, atof, .c_str());
            check(bvars, to_bool, );
            check(svars, , );

#undef check

            conerr("Unknown command: "_str + args[0]);

        }
    } else { cur->second(args); }
}

void execfile(std::string file, bool silent) {
#ifdef __APPLE__
    std::string  path = std::string(GAME_NAME) + ".app/Contents/Resources/" + file;
#else
    std::string& path = file;
#endif /* __APPLE__ */
    std::ifstream in;
    in.open(path);
    if(!in.is_open()) {
        if(!silent) conerr("Could not open script \"" + file + "\"");
        return;
    }
    std::ostringstream cmd_stream;
    cmd_stream << in.rdbuf();
    std::string cmd = cmd_stream.str();
    in.close();
    parsecmd(cmd);
}

command(exec, if(args.size() < 2) conerr("Usage: exec <file>"); else execfile(args[1], false));
