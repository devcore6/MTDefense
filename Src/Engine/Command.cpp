// Credit: Command system is inspired by the system in Cube 2 @ https://sourceforge.net/p/sauerbraten/
#include "Engine.hpp"
#include <filesystem>
#include <fstream>
#include <iomanip>

std::vector<std::pair<std::string, std::string>>    functions;
std::vector<std::pair<std::string, std::string>>    aliases;

std::vector<command_t>                              commands;
std::vector<var_t<intmax_t>>                        ivars;
std::vector<var_t<uint32_t>>                        hvars;
std::vector<var_t<double>>                          dvars;
std::vector<var_t<bool>>                            bvars;
std::vector<svar_t>                                 svars;

std::vector<const_t<intmax_t>>                      iconsts;

void savevars() {
#ifndef __SERVER__
    // Create config folder if it doesn't exist
    std::filesystem::create_directory("Data/Config");

    std::ofstream config;
    config.open("Data/Config/Config.conf");
    if(!config.is_open()) return;

    config << "// Autogenerated main configuration file" << std::endl;
    const auto& save = [&]<typename T>(std::vector<T>&V, std::string prefix = ""_str, std::string suffix = ""_str) { for(auto& var : V) if(var.persist) config << var.name << " " << prefix << *var.ptr << suffix << ";\n"; };
    save(ivars);
    config << std::hex;
    save(hvars, "0x");
    config << std::dec;
    save(dvars);
    save(bvars);
    save(svars, "\""_str, "\""_str);
    config.close();
#endif
}

bool to_bool(std::string& s) { return s == "1" || s == "true"; }

constexpr char identifier_valid_characters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";

void parsecmd(std::string cmd) {
    // Remove comments
    erase_all(cmd, "//", "\n");
    erase_all(cmd, "/*", "*/");

    // Remove line breaks
    erase_all(cmd, "\n");
    erase_all(cmd, "\r");

    // Handle aliases and functions
    if(!match_all(cmd, "=", [](std::string& cmd, size_t pos) -> bool {
        // Get identifier
        size_t start_pos = pos - 1;
        while(start_pos != 0 && cmd[start_pos] == ' ') start_pos--;
        if(start_pos == 0 || !contains(identifier_valid_characters, cmd[start_pos])) {
            conerr("Error: Expected unqualified id before '='");
            return false;
        }
        std::string identifier = "";
        while(start_pos != 0 && contains(identifier_valid_characters, cmd[start_pos])) {
            identifier = ""_str + cmd[start_pos] + identifier;
            start_pos--;
        }
        if(start_pos == 0 && contains(identifier_valid_characters, cmd[start_pos])) identifier = std::string("") + cmd[start_pos] + identifier;

#define check(arr, member) for(auto& x : arr) if(x.member == identifier) { conerr("Cannot redefine built-in \"" + identifier + "\""); return false; }

        check(commands, first);
        check(ivars   , name);
        check(dvars   , name);
        check(bvars   , name);
        check(svars   , name);
        check(iconsts , name);

#undef check

        for(size_t i = 0; i < functions.size(); i++) if(functions[i].first == identifier) functions.erase(functions.begin() + i);
        for(size_t i = 0; i < aliases.size();   i++) if(aliases[i]  .first == identifier) aliases  .erase(aliases  .begin() + i);

        pos++;
        while(cmd[pos] == ' ') pos++;

        // Function declaration
        if(cmd[pos] == '{') {
            pos++;
            size_t decl_start = pos;
            size_t brace_count = 1;
            while(cmd[pos]) {
                if(cmd[pos] == '{') brace_count++;
                else if(cmd[pos] == '}') {
                    brace_count--;
                    if(brace_count == 0) break;
                }
                pos++;
            }
            if(brace_count != 0) conerr("Expected '}'");
            std::string f = cmd.substr(decl_start, pos - decl_start);
            functions.push_back(std::make_pair(identifier, f));
            cmd.erase(start_pos, pos - start_pos);
            return true;
        }
        
        // Alias declaration
        // String
        if(cmd[pos] == '"') {
            pos++;
            size_t end_pos = find_not_escaped(cmd, "\"", pos);
            std::string value = cmd.substr(pos, end_pos - pos);

            // Escape characters

            replace_all(value, "\\\'", "\'");
            replace_all(value, "\\\"", "\"");
            replace_all(value, "\\\?", "\?");
            replace_all(value, "\\\\", "\\");
            replace_all(value, "\\a", "\a");
            replace_all(value, "\\b", "\b");
            replace_all(value, "\\f", "\f");
            replace_all(value, "\\n", "\n");
            replace_all(value, "\\r", "\r");
            replace_all(value, "\\t", "\t");
            replace_all(value, "\\v", "\v");

            aliases.push_back(std::make_pair(identifier, value));
            if(cmd.find(";", end_pos) == std::string::npos) conerr("Expected ';'");
            cmd.erase(start_pos, cmd.find(";", end_pos) - start_pos);
            return true;
        }
        // Non-String
        size_t end_pos = cmd.find(";", pos);
        if(end_pos == std::string::npos) conerr("Expected ';'");
        size_t next_separator = cmd.find(" ", pos);
        std::string value = cmd.substr(pos, min(end_pos, next_separator) - pos
        );
        aliases.push_back(std::make_pair(identifier, value));
        cmd.erase(start_pos, end_pos - start_pos);
        return true;
    })) return;

    std::vector<std::string> cmds = split(cmd, ';', '\"', true);
    for(auto& c : cmds) { execcmd(c); }
}

void execcmd(std::string cmd) {
    std::vector<std::string> args = split(cmd, ' ', '\"');
    if(args.size() == 0) return;

    for(auto& arg : args) {
        replace_all(arg, "\\\'", "\'");
        replace_all(arg, "\\\"", "\"");
        replace_all(arg, "\\\?", "\?");
        replace_all(arg, "\\\\", "\\");
        replace_all(arg, "\\a", "\a");
        replace_all(arg, "\\b", "\b");
        replace_all(arg, "\\f", "\f");
        replace_all(arg, "\\n", "\n");
        replace_all(arg, "\\r", "\r");
        replace_all(arg, "\\t", "\t");
        replace_all(arg, "\\v", "\v");
    }

    for(auto& arg : args) {
        if(arg[0] == '$') {
            arg = arg.substr(1);
            bool found = false;

#define check(arr, conversion, deref) for(auto& x : arr) if(x.name == arg) { arg = conversion(deref x.ptr); found = true; break; }

            check(ivars  , std::to_string, *);
            check(hvars  , std::to_string, *);
            check(dvars  , std::to_string, *);
            check(bvars  , std::to_string, *);
            check(svars  , , *);
            check(iconsts, std::to_string, );

#undef check

            if(found) continue;
            conerr("Unknown alias: "_str + arg);
            arg = "";
        }
    }

    command_t* cur = nullptr;
    for(auto& c : commands) if(c.first == args[0]) cur = &c;

    if(!cur) {
    
        if(args.size() == 1) {

#define check(arr, conversion, deref) for(auto& x : arr) if(x.name == args[0]) { conout(conversion(deref x.ptr)); return; }

            check(ivars  , std::to_string, *);
            check(hvars  , std::to_string, *);
            check(dvars  , std::to_string, *);
            check(bvars  , std::to_string, *);
            check(svars  , , *);
            check(iconsts, std::to_string, );

#undef check

            conerr("Unknown command: "_str + args[0]);

        } else {

#define check(arr, conversion, suffix) for(auto& x : arr) if(x.name == args[0]) { *x.ptr = conversion(args[1] suffix); return; }

            check(ivars, atoll, .c_str());
            check(hvars, [](std::string s) -> uint32_t { if(s.substr(0, 2) == "0x") return std::strtoul(s.c_str(), nullptr, 16); return (uint32_t)std::strtoul(s.c_str(), nullptr, 10); }, );
            check(dvars, atof, .c_str());
            check(bvars, to_bool, );
            check(svars, , );

#undef check

#define check(arr) for(auto& x : arr) if(x.name == args[0]) { conerr("Cannot redefine built-in \""_str + x.name + "\" - it is a constant."); return; }

            check(iconsts);

#undef check

            conerr("Unknown command: "_str + args[0]);

        }
    } else { cur->second(args); }
}

bool execfile(std::string file, bool silent) {
#ifdef __APPLE__
    std::string  path = std::string(GAME_NAME) + ".app/Contents/Resources/" + file;
#else
    std::string& path = file;
#endif /* __APPLE__ */
    std::ifstream in;
    in.open(path);
    if(!in.is_open()) {
        if(!silent) conerr("Could not open script \"" + file + "\"");
        return false;
    }
    std::ostringstream cmd_stream;
    cmd_stream << in.rdbuf();
    std::string cmd = cmd_stream.str();
    in.close();
    parsecmd(cmd);
    return true;
}

void execfolder(std::string folder) {
#ifdef __APPLE__
    std::string  path = std::string(GAME_NAME) + ".app/Contents/Resources/" + file;
#else
    std::string& path = folder;
#endif /* __APPLE__ */
    for(auto&f : std::filesystem::directory_iterator(path))
        if(!std::filesystem::is_directory(f))
            execfile(f.path().string());
}

command(exec, [](std::vector<std::string>& args) {
    if(args.size() < 2) conerr("Usage: exec <file> [file2] [...]");
    else for(size_t i = 1; i < args.size(); i++) execfile(args[i], false);
});

command(execfolder, [](std::vector<std::string>& args) {
    if(args.size() < 2) conerr("Usage: execfolder <folder> [folder2] [...]");
    else for(size_t i = 1; i < args.size(); i++) execfolder(args[i]);
});
